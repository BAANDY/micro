package converter

import (
	"fmt"
	"io"
	"io/ioutil"
	"path"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/micro/micro/v3/service/logger"
)

const (
	openAPISpecFileName = "spec.yaml"
)

// Converter is everything you need to convert Micro protos into an OpenAPI spec:
type Converter struct {
	openAPISpec *openapi3.Swagger
	sourceInfo  *sourceCodeInfo
}

// ConvertFrom tells the convert to work on the given input:
func (c *Converter) ConvertFrom(rd io.Reader) (*plugin.CodeGeneratorResponse, error) {
	logger.Debug("Reading code generation request")
	input, err := ioutil.ReadAll(rd)
	if err != nil {
		logger.Error("Failed to read request: %v", err)
		return nil, err
	}

	req := &plugin.CodeGeneratorRequest{}
	err = proto.Unmarshal(input, req)
	if err != nil {
		logger.Error("Can't unmarshal input: %v", err)
		return nil, err
	}

	c.openAPISpec = &openapi3.Swagger{
		Components: openapi3.NewComponents(),
		Info: &openapi3.Info{
			Title:       "Micro API",
			Description: "Generated by protoc-gen-openapi",
			Version:     "1",
		},
	}
	c.openAPISpec.AddServer(
		&openapi3.Server{
			URL:         "https://cruft.micro.com",
			Description: "Micro API",
		},
	)

	logger.Debug("Converting input: %v", err)
	return c.convert(req)
}

// Converts a proto file into an OpenAPI spec:
func (c *Converter) convertFile(file *descriptor.FileDescriptorProto) error {

	// Input filename:
	protoFileName := path.Base(file.GetName())

	// Otherwise process MESSAGES (packages):
	pkg, ok := c.relativelyLookupPackage(globalPkg, file.GetPackage())
	if !ok {
		return fmt.Errorf("no such package found: %s", file.GetPackage())
	}
	for _, msg := range file.GetMessageType() {

		logger.Info("Generating schema for message (%s) from proto file (%s)", msg.GetName(), protoFileName)

		// Convert the message:
		componentSchema, err := c.convertMessageType(pkg, msg)
		if err != nil {
			logger.Error("Failed to convert (%s): %v", protoFileName, err)
			return err
		}
		c.openAPISpec.Components.Schemas[componentSchema.Title] = componentSchema.NewRef()
	}

	return nil
}

func (c *Converter) convert(req *plugin.CodeGeneratorRequest) (*plugin.CodeGeneratorResponse, error) {

	c.sourceInfo = newSourceCodeInfo(req.GetProtoFile())

	generateTargets := make(map[string]bool)
	for _, file := range req.GetFileToGenerate() {
		generateTargets[file] = true
	}

	res := &plugin.CodeGeneratorResponse{}
	for _, file := range req.GetProtoFile() {
		if file.GetPackage() == "" {
			logger.Warn("Proto file (%s) doesn't specify a package", file.GetName())
			continue
		}

		for _, msg := range file.GetMessageType() {
			logger.Debug("Loading a message (%s/%s)", file.GetPackage(), msg.GetName())
			c.registerType(file.Package, msg)
		}

		if _, ok := generateTargets[file.GetName()]; ok {
			logger.Debug("Converting file (%s)", file.GetName())
			if err := c.convertFile(file); err != nil {
				res.Error = proto.String(fmt.Sprintf("Failed to convert %s: %v", file.GetName(), err))
				return res, err
			}
		}
	}

	// Marshal the OpenAPI spec:
	marshaledSpec, err := c.openAPISpec.MarshalJSON()
	if err != nil {
		logger.Error("Unable to marshal the OpenAPI spec: %v", err)
		return nil, err
	}

	// Add a response file:
	res.File = []*plugin.CodeGeneratorResponse_File{
		{
			Name:    proto.String(openAPISpecFileName),
			Content: proto.String(string(marshaledSpec)),
		},
	}

	return res, nil
}
